-add functions to function scope/call functions from var table?
-support return keyword in signature
-mark expression as not to be evaluated
-track custom type names alongside basename for extra points
-functions called during instantiation? because of stupid expression evaluation
-double parens required for nested function calls like: f = {n:number} => ((f(n-1)) + (f(n-2)))
-need to handle unknown functions in expressions as well
-memoization
-remove regex limit on var names
-functions can contain multiple lines
-register infix in table at runtime?
-it's really annoying when expressions remain unevaluated, they should pretty much always be evaluated if possible
-just mark expression expressions with some little token
-provide a way to invoke a file with args in its own scope
-registering morphisms
- [1, 2 + 5] -> No variable named +(2,5), easy fix, evaluate functions in literal parser if they are being evaluated and match function pattern
- if missing evaluates all variables, it will evaluate chained expressions that reuse the same variable name eagerly
- if it doesn't, it can't evaluate expressions that use outer scope variables
- in error message, write out least specific test that satisfactory match checks for
- better generic formulation of a tuple, right now it is just tuple(any)
- just auto evaluate everything unless it is explicitly tagged as tbd
- type declaration syntax
- type variables in list signatures??
- named types as assignment to signature
- passing functions as arguments, not individual pattern instances, could simply go by function names
- type object instead of global
- create auto constructor function, like: set = {list:[]}, new_set([1,2,3])
- useless unless we can do: set = {(unique(list)):[]} and have it call unique on list
- or that could be a validation and require it to be unique, but that is boring
- we could do some magic, create function: set_list(s:set) which returns the list element and also generate new_set which calls list