-add functions to function scope/call functions from var table?
-support return keyword in signature
-mark expression as not to be evaluated
-functions called during instantiation? because of stupid expression evaluation
-double parens required for nested function calls like: f = {n:number} => ((f(n-1)) + (f(n-2)))
-need to handle unknown functions in expressions as well
-memoization
-remove regex limit on var names
-functions can contain multiple lines
-register infix in table at runtime?
-it's really annoying when expressions remain unevaluated, they should pretty much always be evaluated if possible
-just mark expression expressions with some little token
-provide a way to invoke a file with args in its own scope
-registering morphisms
- [1, 2 + 5] -> No variable named +(2,5), easy fix, evaluate functions in literal parser if they are being evaluated and match function pattern
- if missing evaluates all variables, it will evaluate chained expressions that reuse the same variable name eagerly
- if it doesn't, it can't evaluate expressions that use outer scope variables
- in error message, write out least specific test that satisfactory match checks for
- just auto evaluate everything unless it is explicitly tagged as tbd
- type variables in list signatures??  easy generics, ie. {a:T, b:[T]}
- passing functions as arguments, not individual pattern instances, could simply go by function names
- type object instead of global
- or that could be a validation and require it to be unique, but that is boring
- write out alias non-string objects to console by their alias...just something to deal with noisy printouts
- morphisms could take [char] to [#]
- tests to ensure changes didn't break functionality
- list[] > any, in general going deep on types should be considered worth more than early any
- setters using x(c1, 10)
- things like sets of numbers should be set[number]
- empty lists with any type should satisfy [t] type and be turned into [t] type when a t is added
- not correctly exiting scope after error, [1,2,3] ~> (['item'],(@ < 2)) //no var named @ [1,2,3] ~> (['item'], (item < 2)) item is still defined so this evals to boolean!
- truthy